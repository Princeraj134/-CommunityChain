/// SPDX-License-Identifier: MIT pragma solidity ^0.8.0;/** * @title CommunityChain * @dev A decentralized community governance and funding platform */ contract CommunityChain {// Struct to represent a community project proposal struct Proposal { uint256 id; address proposer; string title; string description; uint256 fundingGoal; uint256 currentFunding; uint256 votesFor; uint256 votesAgainst; uint256 deadline; bool executed; bool exists; }// Struct to represent a community member struct Member { address memberAddress; uint256 reputation; uint256 joinedAt; bool isActive; }// State variables mapping(uint256 => Proposal) public proposals; mapping(address => Member) public members; mapping(uint256 => mapping(address => bool)) public hasVoted; mapping(uint256 => mapping(address => uint256)) public contributions; uint256 public proposalCount; uint256 public memberCount; address public admin;// Events event MemberJoined(address indexed member, uint256 timestamp); event ProposalCreated(uint256 indexed proposalId, address indexed proposer, string title, uint256 fundingGoal); event VoteCast(uint256 indexed proposalId, address indexed voter, bool support); event FundsContributed(uint256 indexed proposalId, address indexed contributor, uint256 amount); event ProposalExecuted(uint256 indexed proposalId, uint256 totalFunding); event ReputationUpdated(address indexed member, uint256 newReputation);// Modifiers modifier onlyAdmin() { require(msg.sender == admin, "Only admin can perform this action"); _; } modifier onlyMember() { require(members[msg.sender].isActive, "Only active members can perform this action"); _; } modifier proposalExists(uint256 _proposalId) { require(proposals[_proposalId].exists, "Proposal does not exist"); _; } constructor() { admin = msg.sender;// Admin automatically becomes first member members[admin] = Member({ memberAddress: admin, reputation: 100, joinedAt: block.timestamp, isActive: true }); memberCount = 1; }/** * @dev Core Function 1: Join the community as a member */ function joinCommunity() external { require(!members[msg.sender].isActive, "Already a member"); members[msg.sender] = Member({ memberAddress: msg.sender, reputation: 10,// Starting reputation joinedAt: block.timestamp, isActive: true }); memberCount++; emit MemberJoined(msg.sender, block.timestamp); }/** * @dev Core Function 2: Create a new proposal for community funding * @param _title Title of the proposal * @param _description Detailed description of the proposal * @param _fundingGoal Amount of ETH needed (in wei) * @param _duration Duration in seconds until deadline */ function createProposal( string memory _title, string memory _description, uint256 _fundingGoal, uint256 _duration ) external onlyMember { require(_fundingGoal > 0, "Funding goal must be greater than 0"); require(_duration > 0, "Duration must be greater than 0"); proposalCount++; proposals[proposalCount] = Proposal({ id: proposalCount, proposer: msg.sender, title: _title, description: _description, fundingGoal: _fundingGoal, currentFunding: 0, votesFor: 0, votesAgainst: 0, deadline: block.timestamp + _duration, executed: false, exists: true });// Award reputation for creating proposal members[msg.sender].reputation += 5; emit ProposalCreated(proposalCount, msg.sender, _title, _fundingGoal); emit ReputationUpdated(msg.sender, members[msg.sender].reputation); }/** * @dev Core Function 3: Vote on a proposal and contribute funds * @param _proposalId ID of the proposal * @param _support True for yes, false for no */ function voteAndContribute(uint256 _proposalId, bool _support) external payable onlyMember proposalExists(_proposalId) { Proposal storage proposal = proposals[_proposalId]; require(block.timestamp < proposal.deadline, "Proposal voting period has ended"); require(!hasVoted[_proposalId][msg.sender], "Already voted on this proposal"); require(!proposal.executed, "Proposal already executed");// Record vote hasVoted[_proposalId][msg.sender] = true; if (_support) { proposal.votesFor++; } else { proposal.votesAgainst++; }// Handle contribution if ETH sent if (msg.value > 0) { require(_support, "Can only contribute to proposals you support"); proposal.currentFunding += msg.value; contributions[_proposalId][msg.sender] += msg.value;// Award reputation for contributing members[msg.sender].reputation += 2; emit FundsContributed(_proposalId, msg.sender, msg.value); emit ReputationUpdated(msg.sender, members[msg.sender].reputation); }// Award reputation for voting members[msg.sender].reputation += 1; emit VoteCast(_proposalId, msg.sender, _support); }/** * @dev Execute a proposal if funding goal reached and voting passed * @param _proposalId ID of the proposal */ function executeProposal(uint256 _proposalId) external proposalExists(_proposalId) { Proposal storage proposal = proposals[_proposalId]; require(block.timestamp >= proposal.deadline, "Proposal voting period not ended"); require(!proposal.executed, "Proposal already executed"); require(proposal.votesFor > proposal.votesAgainst, "Proposal did not pass voting"); require(proposal.currentFunding >= proposal.fundingGoal, "Funding goal not reached"); proposal.executed = true;// Transfer funds to proposer (bool success, ) = payable(proposal.proposer).call{value: proposal.currentFunding}(""); require(success, "Transfer failed");// Award reputation to proposer for successful proposal members[proposal.proposer].reputation += 20; emit ProposalExecuted(_proposalId, proposal.currentFunding); emit ReputationUpdated(proposal.proposer, members[proposal.proposer].reputation); }/** * @dev Get proposal details * @param _proposalId ID of the proposal */ function getProposal(uint256 _proposalId) external view proposalExists(_proposalId) returns ( address proposer, string memory title, string memory description, uint256 fundingGoal, uint256 currentFunding, uint256 votesFor, uint256 votesAgainst, uint256 deadline, bool executed ) { Proposal memory proposal = proposals[_proposalId]; return ( proposal.proposer, proposal.title, proposal.description, proposal.fundingGoal, proposal.currentFunding, proposal.votesFor, proposal.votesAgainst, proposal.deadline, proposal.executed ); }/** * @dev Get member details * @param _member Address of the member */ function getMember(address _member) external view returns ( uint256 reputation, uint256 joinedAt, bool isActive ) { Member memory member = members[_member]; return (member.reputation, member.joinedAt, member.isActive); }/** * @dev Check if address has voted on a proposal */ function checkVoted(uint256 _proposalId, address _voter) external view returns (bool) { return hasVoted[_proposalId][_voter]; }/** * @dev Get contribution amount for a member on a proposal *
/
     function getContribution(uint256 _proposalId, address _contributor) external view returns (uint256) {         return contributions[_proposalId][_contributor];     } }
in
main

Edit

Preview
Indent mode

Spaces
Indent size

2
Line wrap mode

No wrap
Editing function getContribution(uint256 _proposalId, address _contributor) external view returns (uint256) { return contributions[_proposalId][_contributor]; } } file contents
1
